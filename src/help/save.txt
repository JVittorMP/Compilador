/* 

Compiladores II
Jo√£o Vittor de Moura Padilha - 202111310018

*/

/* Declaration Area */
%{
    #undef YY_DECL
    #define YY_DECL int lexScan(std::vector<std::pair<std::string, std::string>> & tokens)
    int line = 1;
%}

Keyword        (boolean|int|class|extends|public|static|void|main|String|System.out.println|length|true|false|this|new|null|while|if|else|return)
Identifier     [a-zA-Z][a-zA-Z0-9_]*
Num            [0-9]+
Operator       [-+*=\<!(==)(!=)(&&)]
Punctuation    [(\)|\(|\}|\{|\]|\[|\;|\.|\,)]
Whitespace     [ \t\r\f]+
 
/*** rules for inputs ***/
%%

{Keyword}		    {tokens.push_back({"Keyword", yytext}); fprintf(yyout, "[Keyword, %s]\n", yytext);}
{Identifier}		{tokens.push_back({"Identifier", yytext}); fprintf(yyout, "[Identifier, %s]\n", yytext);}
{Num}			    {tokens.push_back({"Num", yytext}); fprintf(yyout, "[Num, %s]\n", yytext);}
{Operator}		    {tokens.push_back({"Operator", yytext}); fprintf(yyout, "[Operator, %s]\n", yytext);}
{Punctuation}		{tokens.push_back({"Punctuation", yytext}); fprintf(yyout, "[Punctuation, %s]\n", yytext);}
{Whitespace}		{fprintf(yyout, "%s", "");}
\n                  {tokens.push_back({"Line", std::to_string(line)}); fprintf(yyout, "[Line %d]\n", line); line++;}
<<EOF>>             {tokens.push_back({"End", "$"}); fprintf(yyout, "[End, $]"); return 0;}
.			        {fprintf(yyout, "[Invalid Input (Lexical Error) on Line %d, %s]\n", line, yytext);}

%%
 
/*** User code section***/
/* int main()
{

int x = 10;

extern FILE *yyin, *yyout;
yyin = fopen("input.txt", "r");
yyout = fopen("tokens.txt", "w");
lexScan(x);
return 0;

}*/